# 后端：音高 ↔ 古琴指法映射模块（Pitch ↔ Fingering）

本文档把 GuqinAuto 的两个核心“可计算方向”写死，并明确它们如何被复用：

1) **简谱/音高 → 古琴指法候选（1→多）**：也就是我们之前说的 stage1  
2) **古琴指法 → 音高/简谱（1→1）**：在给定定弦/移调与真值字段齐全的前提下，应当是确定可计算的

同时，我们明确一个编辑器层面非常重要的产品选择：

- **允许前后不一致**：用户在编辑过程中，允许 staff1（简谱/pitch）与 staff2（减字谱指法真值）暂时不一致  
- **持续检查与提示**：后端持续用本模块做一致性检查，把不一致点作为 warning 返回给前端 UI（不阻塞编辑，但不允许静默忽略）

> 规范性语言：MUST / SHOULD / MAY

---

## 0. 前提：MusicXML 是唯一真源（写死）

本模块不会引入新的“第二真源”。所有推导、检查都以 MusicXML 真源为依据：

- staff1：节奏锚点（以及需要时的绝对 pitch）
- staff2：古琴指法真值（GuqinJZP@... 的结构化字段）

相关规范见：`docs/data/GuqinJZP-MusicXML Profile v0.2.md`

---

## 1. 方向 A：Pitch → Fingering candidates（stage1，1→多）

### 1.1 输入（MUST）

- 目标 pitch（绝对音高），来自 staff1 `<pitch>`（或“简谱度数 + 主音/调性”编译写回后得到的 `<pitch>`）
- 项目定弦 `tuning`（7 弦开弦 MIDI + transpose）
- 选项：temperament / 最大把位范围 / 是否包含泛音候选等

### 1.2 输出（MUST）

对每个事件（eid + slot），输出一组候选：

- 弦（string 1..7）
- technique（open/press/harmonic）
- pitch_midi（候选对应音高）
- 连续位置真值（未来 Profile v0.3：`pos_ratio`）
- 以及必要的来源信息（用于可解释性）

> 该方向的实现现阶段由后端 stage1 接口与 PositionEngine 承担。

实现位置：

- Pitch → Fingering（stage1 候选枚举）：`backend/src/guqinauto_backend/position_engine.py`
- Fingering → Pitch（确定推导/用于一致性检查）：`backend/src/guqinauto_backend/guqin_fingering_pitch.py`

---

## 2. 方向 B：Fingering → Pitch（1→1，确定可计算）

### 2.1 设计目标（MUST）

给定：

- 项目定弦（7 弦开弦 pitch）
- 一个事件在 staff2 的“指法真值字段”

我们 MUST 能确定性地计算出该事件的“应当发声的 pitch”（或 chord 的多个 pitch），用于：

- 校验：staff1 与 staff2 是否一致
- 反向编译：从指法真值生成/修正 staff1 pitch（当用户明确触发“对齐/修复”时）
- 导出：MIDI/音频派生物的可复现生成（注意它们仍然是 export-only 的有损派生物）

### 2.2 必要真值（MUST）

仅靠 Profile v0.2 的 `hui/fen`，无法在不做假设的情况下“精确确定 pitch”：

- 徽位更像“物理位置标记”，不是音级；不同学派/律制与现实乐器都会有偏差
- 如果我们仅凭 `hui/fen` 硬算音高，本质上就是在做隐式假设与静默降级（违背“正确地失败”）

因此我们把“可逆的一对一计算”写死为 **Profile v0.3** 的必要能力（见 `docs/data/GuqinJZP-MusicXML Profile v0.2.md` 的 v0.3 方向）：

- `pos_ratio`：连续位置真值（0..1，表示有效弦长比例）
- `sound`：声源类别（open/pressed/harmonic）
- 对 harmonic：需要明确的节点信息（例如 `harmonic_n`/`harmonic_k` 或等价表达）

当这些真值齐全时，Fingering → Pitch MUST 是确定的。

> 现阶段（v0.2）：该方向只能做**部分检查**（例如“散音/开弦”可确定），其它情况 MUST 明确提示“无法判断，需要 v0.3 真值”，不允许猜测。

---

## 3. 编辑器的一致性策略（允许不一致，但持续提示）

### 3.1 状态定义（建议）

编辑器面向用户至少要区分三种状态：

1) `pitch_resolved=false`：staff1 缺少绝对 pitch（阻塞 stage1/stage2 与 MIDI/音频导出）
2) `pitch_resolved=true` 且 `consistency_warnings=[]`：可推荐/可导出，且简谱与指法一致（或至少可检查的部分一致）
3) `pitch_resolved=true` 但存在 `consistency_warnings`：允许继续编辑，但 UI 必须提示“哪里不一致/为什么无法判断”

### 3.2 后端输出（MUST）

后端 MUST 提供一个轻量接口给前端（当前落在 `/projects/{id}/status`）：

- `pitch_issues[]`：阻塞型问题（例如 staff1 pitch 未解析）
- `consistency_warnings[]`：提示型问题（不阻塞编辑）

其中 `consistency_warnings` 的原则是：

- 能判断 → 给出 `expected_pitch_midi` 与 `actual_pitch_midi`，并说明 reason
- 不能判断 → reason 必须明确指出缺少的真值（例如 “需要 v0.3 pos_ratio/sound”）

---

## 4. 显示层策略（先不做字形渲染）

我们明确一个务实取舍：**先用不损失含义的文本表示**来显示减字谱（例如 `散勾三`）。

- `jzp_text` 是“可重复生成的显示层”，由结构化真值字段生成
- 前端短期只需要可靠显示/可复制/可检索即可，不强依赖字体/SVG 字形渲染
- 未来如果要做精致字形渲染（字体或 SVG），应当作为显示层的可选升级，不改变真源与编辑协议
